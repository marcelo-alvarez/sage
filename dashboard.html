<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Orchestrator Dashboard</title>
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* Header */
        .header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.2em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        /* Mode Switcher */
        .mode-switcher {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mode-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .mode-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #34495e;
            transition: .4s;
            border-radius: 30px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #e74c3c;
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        .mode-label {
            font-size: 14px;
            font-weight: 500;
        }

        .btn-skip-discovery {
            background: #34495e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
        }

        .btn-skip-discovery:hover {
            background: #2c3e50;
        }

        .btn-skip-discovery.active {
            background: #e74c3c;
        }

        /* Main Content */
        .main-content {
            padding: 40px;
        }

        /* Status Overview */
        .status-overview {
            background: #ecf0f1;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .current-task {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .task-description {
            color: #7f8c8d;
            font-size: 1.1em;
            line-height: 1.5;
        }

        /* Workflow Timeline */
        .workflow-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.8em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 25px;
            text-align: center;
        }

        .workflow-timeline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            overflow-x: auto;
            min-height: 120px;
        }

        .workflow-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 140px;
            position: relative;
            flex-shrink: 0;
        }

        .step-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .step-icon.pending {
            background: #ecf0f1;
            color: #95a5a6;
            border: 3px solid #bdc3c7;
        }

        .step-icon.in-progress {
            background: #3498db;
            color: white;
            border: 3px solid #2980b9;
            animation: pulse 2s infinite;
        }

        .step-icon.completed {
            background: #27ae60;
            color: white;
            border: 3px solid #229954;
        }

        .step-icon.gate.pending {
            background: #f39c12;
            color: white;
            border: 3px solid #e67e22;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .step-label {
            font-size: 0.9em;
            font-weight: 600;
            text-align: center;
            color: #2c3e50;
            max-width: 120px;
            line-height: 1.3;
        }

        .workflow-connector {
            flex: 1;
            height: 4px;
            background: #bdc3c7;
            margin: 0 15px;
            position: relative;
            top: -30px;
        }

        .workflow-connector.active {
            background: #3498db;
        }

        .workflow-connector.completed {
            background: #27ae60;
        }

        /* Agent Details */
        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .agent-card {
            background: white;
            border: 2px solid #ecf0f1;
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .agent-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .agent-card.active {
            border-color: #3498db;
            background: #f8fbff;
        }

        .agent-card.completed {
            border-color: #27ae60;
            background: #f8fff9;
        }

        .agent-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .agent-name {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
        }

        .agent-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .agent-status.pending {
            background: #ecf0f1;
            color: #7f8c8d;
        }

        .agent-status.in-progress {
            background: #3498db;
            color: white;
        }

        .agent-status.completed {
            background: #27ae60;
            color: white;
        }

        .agent-description {
            color: #7f8c8d;
            line-height: 1.5;
            font-size: 0.95em;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #ecf0f1;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-2px);
        }

        .last-updated {
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 20px;
        }

        /* Gate Decision Controls */
        .gate-controls {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            display: none;
        }

        .gate-controls.active {
            display: block;
        }

        .gate-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #856404;
            margin-bottom: 15px;
            text-align: center;
        }

        .gate-content {
            color: #856404;
            margin-bottom: 20px;
            line-height: 1.5;
            text-align: center;
        }

        .gate-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-gate {
            background: #ffc107;
            color: #212529;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
        }

        .btn-gate:hover {
            background: #e0a800;
            transform: translateY(-2px);
        }

        .btn-gate:disabled {
            background: #d6d6d6;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .gate-feedback {
            text-align: center;
            font-size: 0.9em;
            margin-top: 15px;
            min-height: 20px;
        }

        .gate-feedback.loading {
            color: #007bff;
        }

        .gate-feedback.success {
            color: #28a745;
        }

        .gate-feedback.error {
            color: #dc3545;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 20px;
            }

            .mode-switcher {
                position: static;
                margin-top: 15px;
            }

            .main-content {
                padding: 20px;
            }

            .workflow-timeline {
                padding: 20px;
                flex-direction: column;
                gap: 20px;
            }

            .workflow-connector {
                display: none;
            }

            .agents-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .gate-buttons {
                flex-direction: column;
                align-items: center;
            }

            .btn-gate {
                width: 100%;
                max-width: 200px;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8em;
            }

            .section-title {
                font-size: 1.5em;
            }

            .step-icon {
                width: 50px;
                height: 50px;
                font-size: 1.2em;
            }
        }

        /* File Viewer Panel */
        .file-viewer {
            background: #f8f9fa;
            border-radius: 12px;
            overflow: hidden;
        }

        .file-tabs {
            display: flex;
            background: #ecf0f1;
            border-bottom: 2px solid #bdc3c7;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .file-tabs::-webkit-scrollbar {
            height: 4px;
        }

        .file-tabs::-webkit-scrollbar-track {
            background: #ecf0f1;
        }

        .file-tabs::-webkit-scrollbar-thumb {
            background: #bdc3c7;
            border-radius: 2px;
        }

        .file-tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 15px 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            min-width: 140px;
            white-space: nowrap;
        }

        .file-tab:hover {
            background: #ddd;
            color: #2c3e50;
        }

        .file-tab.active {
            background: white;
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .file-tab-icon {
            font-size: 1.1em;
        }

        .file-content-container {
            position: relative;
            min-height: 400px;
        }

        .file-content {
            padding: 30px;
            background: white;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            color: #2c3e50;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .file-placeholder {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 60px 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        .file-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            color: #7f8c8d;
        }

        .file-error {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            color: #e74c3c;
        }

        .error-icon {
            font-size: 2em;
        }

        .error-message {
            font-size: 1.1em;
            font-weight: 500;
        }

        .btn-retry {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .btn-retry:hover {
            background: #c0392b;
        }

        /* Responsive Design for File Viewer */
        @media (max-width: 768px) {
            .file-tabs {
                padding: 0 10px;
            }

            .file-tab {
                padding: 12px 16px;
                min-width: 120px;
                font-size: 0.9em;
            }

            .file-content {
                padding: 20px;
                font-size: 0.85em;
            }

            .file-content-container {
                min-height: 300px;
            }
        }

        @media (max-width: 480px) {
            .file-tab {
                padding: 10px 12px;
                min-width: 100px;
                font-size: 0.85em;
            }

            .file-content {
                padding: 15px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="mode-switcher">
                <span class="mode-label">Regular</span>
                <label class="mode-toggle">
                    <input type="checkbox" id="modeToggle">
                    <span class="slider"></span>
                </label>
                <span class="mode-label">Meta</span>
                <button class="btn-skip-discovery" id="skipDiscoveryBtn" onclick="skipAPIDiscovery()" title="Use mock data instead of discovering API server">
                    📶 Mock Mode
                </button>
            </div>
            <h1>Claude Code Orchestrator</h1>
            <p>Workflow Progress Dashboard</p>
        </header>

        <main class="main-content">
            <div class="status-overview">
                <div class="current-task">Current Task</div>
                <div class="task-description" id="currentTask">
                    Create dashboard HTML interface implementing the visual workflow progress design
                </div>
            </div>

            <section class="workflow-section">
                <h2 class="section-title">Workflow Progress</h2>
                <div class="workflow-timeline" id="workflowTimeline">
                    <!-- Workflow steps will be dynamically generated -->
                </div>
            </section>

            <section class="workflow-section">
                <h2 class="section-title">Agent Details</h2>
                <div class="agents-grid" id="agentsGrid">
                    <!-- Agent cards will be dynamically generated -->
                </div>
            </section>

            <!-- File Viewer Panel -->
            <section class="workflow-section">
                <h2 class="section-title">Agent Output Files</h2>
                <div class="file-viewer">
                    <div class="file-tabs" id="fileTabs">
                        <!-- File tabs will be dynamically generated -->
                    </div>
                    <div class="file-content-container">
                        <div class="file-content" id="fileContent">
                            <div class="file-placeholder">Select a file tab to view its content</div>
                        </div>
                        <div class="file-loading" id="fileLoading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <span>Loading file content...</span>
                        </div>
                        <div class="file-error" id="fileError" style="display: none;">
                            <div class="error-icon">⚠️</div>
                            <div class="error-message" id="errorMessage">Failed to load file</div>
                            <button class="btn-retry" onclick="retryFileLoad()">Retry</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Gate Decision Controls -->
            <div class="gate-controls" id="gateControls">
                <div class="gate-title" id="gateTitle">Gate Decision Required</div>
                <div class="gate-content" id="gateContent">Please choose an action to continue the workflow.</div>
                <div class="gate-buttons" id="gateButtons">
                    <!-- Gate decision buttons will be dynamically generated -->
                </div>
                <div class="gate-feedback" id="gateFeedback"></div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="refreshStatus()">Refresh Status</button>
                <button class="btn btn-secondary" onclick="simulateProgress()">Simulate Progress</button>
            </div>

            <div class="last-updated" id="lastUpdated">
                Last updated: <span id="updateTime"></span>
            </div>
        </main>
    </div>

    <script>
        // Mock data structures matching .agent-outputs/ file formats
        const mockStatusData = {
            regular: {
                currentTask: "Create dashboard HTML interface implementing the visual workflow progress design",
                workflow: [
                    { name: "Explorer", status: "completed", type: "agent", icon: "🔍" },
                    { name: "Criteria Gate", status: "completed", type: "gate", icon: "🚪" },
                    { name: "Planner", status: "completed", type: "agent", icon: "📋" },
                    { name: "Coder", status: "in-progress", type: "agent", icon: "💻" },
                    { name: "Scribe", status: "pending", type: "agent", icon: "📝" },
                    { name: "Verifier", status: "pending", type: "agent", icon: "✅" },
                    { name: "Completion Gate", status: "pending", type: "gate", icon: "🏁" }
                ],
                agents: [
                    {
                        name: "Explorer",
                        status: "completed",
                        description: "Analyzed task requirements and identified patterns, dependencies, and constraints for the dashboard implementation."
                    },
                    {
                        name: "Planner",
                        status: "completed",
                        description: "Created detailed implementation plan with step-by-step approach and success criteria."
                    },
                    {
                        name: "Coder",
                        status: "in-progress",
                        description: "Currently implementing the dashboard HTML interface with embedded CSS and JavaScript."
                    },
                    {
                        name: "Scribe",
                        status: "pending",
                        description: "Will document the implementation and create usage instructions."
                    },
                    {
                        name: "Verifier",
                        status: "pending",
                        description: "Will test the dashboard functionality and verify all success criteria are met."
                    }
                ]
            },
            meta: {
                currentTask: "Meta-mode: Create dashboard HTML interface implementing the visual workflow progress design",
                workflow: [
                    { name: "Explorer", status: "completed", type: "agent", icon: "🔍" },
                    { name: "Criteria Gate", status: "completed", type: "gate", icon: "🚪" },
                    { name: "Planner", status: "completed", type: "agent", icon: "📋" },
                    { name: "Coder", status: "in-progress", type: "agent", icon: "💻" },
                    { name: "Scribe", status: "pending", type: "agent", icon: "📝" },
                    { name: "Verifier", status: "pending", type: "agent", icon: "✅" },
                    { name: "Completion Gate", status: "pending", type: "gate", icon: "🏁" }
                ],
                agents: [
                    {
                        name: "Explorer",
                        status: "completed",
                        description: "Analyzed task requirements and identified patterns, dependencies, and constraints for the dashboard implementation in meta mode."
                    },
                    {
                        name: "Planner",
                        status: "completed",
                        description: "Created detailed implementation plan with step-by-step approach and success criteria in meta mode."
                    },
                    {
                        name: "Coder",
                        status: "in-progress",
                        description: "Currently implementing the dashboard HTML interface with embedded CSS and JavaScript in meta mode."
                    },
                    {
                        name: "Scribe",
                        status: "pending",
                        description: "Will document the implementation and create usage instructions in meta mode."
                    },
                    {
                        name: "Verifier",
                        status: "pending",
                        description: "Will test the dashboard functionality and verify all success criteria are met in meta mode."
                    }
                ]
            }
        };

        let currentMode = 'regular';
        let simulationStep = 0;
        let realTimeData = null;
        let useRealAPI = true;
        let currentGateState = null;
        let isProcessingDecision = false;
        let discoveredAPIPort = null;
        let forceMockMode = false;
        const CACHE_EXPIRY_MINUTES = 5;

        // Check URL for mock parameter
        function checkMockParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('mock') === 'true';
        }

        // Get cached port from localStorage
        function getCachedPort() {
            try {
                const cached = localStorage.getItem('orchestrator_api_port');
                if (cached) {
                    const data = JSON.parse(cached);
                    const now = new Date().getTime();
                    const cacheTime = new Date(data.timestamp).getTime();
                    const ageMinutes = (now - cacheTime) / (1000 * 60);
                    
                    if (ageMinutes < CACHE_EXPIRY_MINUTES) {
                        console.log(`Using cached API port: ${data.port}`);
                        return data.port;
                    } else {
                        localStorage.removeItem('orchestrator_api_port');
                        console.log('Cached port expired, will rediscover');
                    }
                }
            } catch (e) {
                console.log('Error reading cached port:', e.message);
            }
            return null;
        }

        // Cache discovered port in localStorage
        function setCachedPort(port) {
            try {
                const data = {
                    port: port,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('orchestrator_api_port', JSON.stringify(data));
                console.log(`Cached API port: ${port}`);
            } catch (e) {
                console.log('Error caching port:', e.message);
            }
        }

        // Optimized API Port Discovery with retry logic
        async function discoverAPIPort(retryCount = 0) {
            const possiblePorts = [8000, 8001, 8002]; // Reduced from 10 ports to 3
            const maxRetries = 1; // Reduced from 3 to 1
            
            for (const port of possiblePorts) {
                try {
                    const response = await fetch(`http://localhost:${port}/api/status`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(1000) // Reduced from 3000ms to 1000ms
                    });
                    if (response.ok) {
                        console.log(`API server discovered on port ${port}`);
                        setCachedPort(port); // Cache successful discovery
                        return port;
                    }
                } catch (e) {
                    // Port not available, continue to next
                }
            }
            
            // If first attempt failed and we haven't exceeded retries, wait and try again
            if (retryCount < maxRetries) {
                console.log(`API discovery attempt ${retryCount + 1} failed, retrying in 1 second...`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Reduced from 2000ms
                return discoverAPIPort(retryCount + 1);
            }
            
            throw new Error('No API server found on any port after retries');
        }

        // Skip API discovery and use mock data
        function skipAPIDiscovery() {
            forceMockMode = true;
            useRealAPI = false;
            discoveredAPIPort = null;
            
            // Update button state
            const btn = document.getElementById('skipDiscoveryBtn');
            btn.classList.add('active');
            btn.textContent = '📶 Mock Active';
            
            console.log('Switched to mock mode - using fallback data');
            renderMockData();
            refreshFileViewer();
        }

        // Get API Base URL
        function getAPIBaseURL() {
            if (discoveredAPIPort) {
                return `http://localhost:${discoveredAPIPort}`;
            }
            return 'http://localhost:8000'; // fallback
        }

        // Gate decision mappings
        const gateDecisionLabels = {
            'approve-criteria': 'Approve Criteria',
            'modify-criteria': 'Modify Criteria',
            'retry-explorer': 'Retry Explorer',
            'approve-completion': 'Approve Completion',
            'retry-from-planner': 'Retry from Planner',
            'retry-from-coder': 'Retry from Coder',
            'retry-from-verifier': 'Retry from Verifier'
        };

        const gateTypeDecisions = {
            'Criteria Gate': ['approve-criteria', 'modify-criteria', 'retry-explorer'],
            'Completion Gate': ['approve-completion', 'retry-from-planner', 'retry-from-coder', 'retry-from-verifier']
        };

        // Initialize dashboard with optimized discovery logic
        async function initDashboard() {
            // Step 1: Check URL parameter for mock mode
            if (checkMockParameter()) {
                console.log('Mock mode requested via URL parameter');
                skipAPIDiscovery();
                initFileViewer();
                return;
            }
            
            // Step 2: Check if already in forced mock mode
            if (forceMockMode) {
                console.log('Already in mock mode, skipping discovery');
                renderMockData();
                initFileViewer();
                return;
            }
            
            // Step 3: Try cached port first
            if (!discoveredAPIPort) {
                const cachedPort = getCachedPort();
                if (cachedPort) {
                    discoveredAPIPort = cachedPort;
                    useRealAPI = true;
                }
            }
            
            // Step 4: Test cached/existing port
            if (discoveredAPIPort) {
                try {
                    const response = await fetch(`http://localhost:${discoveredAPIPort}/api/status`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(1000)
                    });
                    if (response.ok) {
                        console.log(`Using cached/existing API port: ${discoveredAPIPort}`);
                        useRealAPI = true;
                        await fetchRealStatus();
                        initFileViewer();
                        return;
                    } else {
                        console.log('Cached port no longer valid, will rediscover');
                        discoveredAPIPort = null;
                    }
                } catch (error) {
                    console.log('Cached port test failed, will rediscover');
                    discoveredAPIPort = null;
                }
            }
            
            // Step 5: Only discover as last resort
            try {
                discoveredAPIPort = await discoverAPIPort();
                console.log(`Using discovered API server on port ${discoveredAPIPort}`);
                useRealAPI = true;
                await fetchRealStatus();
            } catch (error) {
                console.warn('API server discovery failed:', error.message);
                console.log('Using mock data as fallback');
                useRealAPI = false;
                renderMockData();
            }
            
            initFileViewer();
        }

        // Fetch real status from API
        async function fetchRealStatus() {
            try {
                const apiUrl = `${getAPIBaseURL()}/api/status?mode=${currentMode}`;
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });
                
                if (response.ok) {
                    realTimeData = await response.json();
                    renderRealData();
                    console.log('Successfully fetched real status data');
                } else {
                    throw new Error(`API responded with status ${response.status}`);
                }
            } catch (error) {
                console.log('API fetch failed, keeping current data:', error.message);
                // Don't immediately fall back to mock data - just log the error
                // and keep the current state. The refresh button can retry.
                if (!realTimeData) {
                    console.log('No previous data available, using mock data');
                    renderMockData();
                }
            }
        }

        // Render data from real API
        function renderRealData() {
            if (!realTimeData) return;
            
            renderWorkflowTimeline(realTimeData.workflow);
            renderAgentsGrid(realTimeData.agents);
            updateCurrentTask(realTimeData.currentTask);
            renderGateControls(realTimeData.workflow);
            updateLastUpdated();
        }

        // Render mock data (fallback)
        function renderMockData() {
            renderWorkflowTimeline();
            renderAgentsGrid();
            updateCurrentTask();
            renderGateControls();
            updateLastUpdated();
        }

        // Mode switching
        document.getElementById('modeToggle').addEventListener('change', function() {
            currentMode = this.checked ? 'meta' : 'regular';
            initDashboard();
            refreshFileViewer();
        });

        // Render workflow timeline
        function renderWorkflowTimeline(workflowData) {
            const timeline = document.getElementById('workflowTimeline');
            const workflow = workflowData || mockStatusData[currentMode].workflow;
            
            timeline.innerHTML = '';
            
            workflow.forEach((step, index) => {
                // Create step element
                const stepDiv = document.createElement('div');
                stepDiv.className = 'workflow-step';
                
                const iconDiv = document.createElement('div');
                iconDiv.className = `step-icon ${step.status}${step.type === 'gate' ? ' gate' : ''}`;
                iconDiv.textContent = step.icon;
                
                const labelDiv = document.createElement('div');
                labelDiv.className = 'step-label';
                labelDiv.textContent = step.name;
                
                stepDiv.appendChild(iconDiv);
                stepDiv.appendChild(labelDiv);
                timeline.appendChild(stepDiv);
                
                // Add connector (except for last item)
                if (index < workflow.length - 1) {
                    const connector = document.createElement('div');
                    connector.className = `workflow-connector ${getConnectorStatus(workflow, index)}`;
                    timeline.appendChild(connector);
                }
            });
        }

        // Get connector status based on adjacent steps
        function getConnectorStatus(workflow, index) {
            const currentStep = workflow[index];
            const nextStep = workflow[index + 1];
            
            if (currentStep.status === 'completed') {
                return 'completed';
            } else if (currentStep.status === 'in-progress') {
                return 'active';
            }
            return '';
        }

        // Render agents grid
        function renderAgentsGrid(agentsData) {
            const grid = document.getElementById('agentsGrid');
            const agents = agentsData || mockStatusData[currentMode].agents;
            
            grid.innerHTML = '';
            
            agents.forEach(agent => {
                const card = document.createElement('div');
                card.className = `agent-card ${agent.status}`;
                
                card.innerHTML = `
                    <div class="agent-header">
                        <div class="agent-name">${agent.name}</div>
                        <div class="agent-status ${agent.status}">${agent.status.replace('-', ' ')}</div>
                    </div>
                    <div class="agent-description">${agent.description}</div>
                `;
                
                grid.appendChild(card);
            });
        }

        // Update current task display
        function updateCurrentTask(taskText) {
            const currentTask = taskText || mockStatusData[currentMode].currentTask;
            document.getElementById('currentTask').textContent = currentTask;
        }

        // Update last updated time
        function updateLastUpdated() {
            const now = new Date();
            document.getElementById('updateTime').textContent = now.toLocaleTimeString();
        }

        // Refresh status
        async function refreshStatus() {
            // If we're not using real API, try to discover it again
            if (!useRealAPI || !discoveredAPIPort) {
                console.log('Attempting to reconnect to API server...');
                try {
                    discoveredAPIPort = await discoverAPIPort();
                    console.log(`Reconnected to API server on port ${discoveredAPIPort}`);
                    useRealAPI = true;
                } catch (error) {
                    console.log('Still no API server available, using mock data');
                    useRealAPI = false;
                }
            }
            
            if (useRealAPI && discoveredAPIPort) {
                await fetchRealStatus();
            } else {
                updateLastUpdated();
                console.log(`Using mock data for .agent-outputs${currentMode === 'meta' ? '-meta' : ''}/`);
                renderMockData();
            }
            refreshFileViewer();
        }

        // Simulate progress for demonstration
        function simulateProgress() {
            const workflow = mockStatusData[currentMode].workflow;
            const agents = mockStatusData[currentMode].agents;
            
            // Find first non-completed item and advance it
            for (let i = 0; i < workflow.length; i++) {
                if (workflow[i].status === 'pending') {
                    workflow[i].status = 'in-progress';
                    break;
                } else if (workflow[i].status === 'in-progress') {
                    workflow[i].status = 'completed';
                    // Start next item if it exists and is an agent
                    if (i + 1 < workflow.length && workflow[i + 1].type === 'agent') {
                        workflow[i + 1].status = 'in-progress';
                    }
                    break;
                }
            }
            
            // Update corresponding agent status
            for (let agent of agents) {
                const workflowItem = workflow.find(w => w.name === agent.name);
                if (workflowItem) {
                    agent.status = workflowItem.status;
                }
            }
            
            initDashboard();
        }

        // Auto-refresh simulation (every 30 seconds)
        setInterval(() => {
            refreshStatus();
        }, 30000);

        // Render gate decision controls
        function renderGateControls(workflowData) {
            const workflow = workflowData || mockStatusData[currentMode].workflow;
            const gateControls = document.getElementById('gateControls');
            const gateTitle = document.getElementById('gateTitle');
            const gateContent = document.getElementById('gateContent');
            const gateButtons = document.getElementById('gateButtons');
            const gateFeedback = document.getElementById('gateFeedback');
            
            // Find active gate
            const activeGate = workflow.find(step => 
                step.type === 'gate' && step.status === 'pending'
            );
            
            if (activeGate && !isProcessingDecision) {
                // Show gate controls
                gateControls.classList.add('active');
                gateTitle.textContent = `${activeGate.name} Decision Required`;
                gateContent.textContent = `Please choose an action to continue the workflow past the ${activeGate.name}.`;
                
                // Get available decisions for this gate type
                const availableDecisions = gateTypeDecisions[activeGate.name] || 
                    Object.keys(gateDecisionLabels);
                
                // Generate buttons
                gateButtons.innerHTML = '';
                availableDecisions.forEach(decisionType => {
                    const button = document.createElement('button');
                    button.className = 'btn-gate';
                    button.textContent = gateDecisionLabels[decisionType];
                    button.onclick = () => makeGateDecision(decisionType);
                    gateButtons.appendChild(button);
                });
                
                // Clear feedback
                gateFeedback.textContent = '';
                gateFeedback.className = 'gate-feedback';
                
                currentGateState = activeGate;
            } else {
                // Hide gate controls
                gateControls.classList.remove('active');
                currentGateState = null;
            }
        }

        // Make gate decision
        async function makeGateDecision(decisionType) {
            if (isProcessingDecision) return;
            
            isProcessingDecision = true;
            const gateButtons = document.getElementById('gateButtons');
            const gateFeedback = document.getElementById('gateFeedback');
            
            // Disable all buttons and show loading
            const buttons = gateButtons.querySelectorAll('.btn-gate');
            buttons.forEach(btn => btn.disabled = true);
            
            gateFeedback.className = 'gate-feedback loading';
            gateFeedback.innerHTML = '<span class="loading-spinner"></span>Processing decision...';
            
            try {
                // Use existing OrchestratorAPI if available, otherwise direct fetch
                let result;
                if (window.OrchestratorAPI && window.OrchestratorAPI.makeDecision) {
                    result = await window.OrchestratorAPI.makeDecision(decisionType, { mode: currentMode });
                } else {
                    // Fallback to direct API call
                    const response = await fetch(`${getAPIBaseURL()}/api/gate-decision?mode=${currentMode}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ decision_type: decisionType })
                    });
                    result = await response.json();
                }
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Show success message
                gateFeedback.className = 'gate-feedback success';
                gateFeedback.textContent = `✓ Decision processed: ${gateDecisionLabels[decisionType]}`;
                
                // Refresh status after short delay
                setTimeout(() => {
                    refreshStatus();
                    isProcessingDecision = false;
                }, 1500);
                
            } catch (error) {
                // Show error message
                gateFeedback.className = 'gate-feedback error';
                gateFeedback.textContent = `✗ Error: ${error.message}`;
                
                // Re-enable buttons
                buttons.forEach(btn => btn.disabled = false);
                isProcessingDecision = false;
            }
        }

        // File Viewer Configuration
        const FILE_TABS = [
            { filename: 'exploration.md', label: 'Exploration', icon: '🔍' },
            { filename: 'plan.md', label: 'Plan', icon: '📋' },
            { filename: 'changes.md', label: 'Changes', icon: '💻' },
            { filename: 'verification.md', label: 'Verification', icon: '✅' }
        ];

        let currentActiveFile = null;
        let lastFailedFile = null;

        // Initialize File Viewer
        function initFileViewer() {
            renderFileTabs();
            // Load first file by default
            if (FILE_TABS.length > 0) {
                switchFileTab(FILE_TABS[0].filename);
            }
        }

        // Render File Tabs
        function renderFileTabs() {
            const tabsContainer = document.getElementById('fileTabs');
            tabsContainer.innerHTML = '';

            FILE_TABS.forEach(tab => {
                const button = document.createElement('button');
                button.className = 'file-tab';
                button.onclick = () => switchFileTab(tab.filename);
                
                button.innerHTML = `
                    <span class="file-tab-icon">${tab.icon}</span>
                    <span>${tab.label}</span>
                `;
                
                tabsContainer.appendChild(button);
            });
        }

        // Switch File Tab
        async function switchFileTab(filename) {
            // Update active tab styling
            const tabs = document.querySelectorAll('.file-tab');
            tabs.forEach((tab, index) => {
                if (FILE_TABS[index].filename === filename) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Load file content
            currentActiveFile = filename;
            await fetchFileContent(filename);
        }

        // Fetch File Content
        async function fetchFileContent(filename) {
            showFileLoading();

            try {
                const apiUrl = `${getAPIBaseURL()}/api/outputs/${filename}?mode=${currentMode}`;
                const response = await fetch(apiUrl);

                if (response.ok) {
                    const content = await response.text();
                    displayFileContent(content, filename);
                } else if (response.status === 404) {
                    showFileError(`File "${filename}" not found`);
                } else {
                    throw new Error(`Server responded with status ${response.status}`);
                }
            } catch (error) {
                console.log(`Failed to load ${filename}:`, error.message);
                showFileError(`Failed to load file: ${error.message}`);
                lastFailedFile = filename;
            }
        }

        // Display File Content
        function displayFileContent(content, filename) {
            const contentContainer = document.getElementById('fileContent');
            const loadingContainer = document.getElementById('fileLoading');
            const errorContainer = document.getElementById('fileError');

            // Hide loading and error states
            loadingContainer.style.display = 'none';
            errorContainer.style.display = 'none';

            // Escape HTML to prevent XSS
            const escapedContent = content
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');

            // Display content
            contentContainer.innerHTML = escapedContent;
            contentContainer.style.display = 'block';
        }

        // Show File Loading State
        function showFileLoading() {
            const contentContainer = document.getElementById('fileContent');
            const loadingContainer = document.getElementById('fileLoading');
            const errorContainer = document.getElementById('fileError');

            contentContainer.style.display = 'none';
            errorContainer.style.display = 'none';
            loadingContainer.style.display = 'flex';
        }

        // Show File Error State
        function showFileError(message) {
            const contentContainer = document.getElementById('fileContent');
            const loadingContainer = document.getElementById('fileLoading');
            const errorContainer = document.getElementById('fileError');
            const errorMessage = document.getElementById('errorMessage');

            contentContainer.style.display = 'none';
            loadingContainer.style.display = 'none';
            errorMessage.textContent = message;
            errorContainer.style.display = 'flex';
        }

        // Retry File Load
        function retryFileLoad() {
            if (lastFailedFile) {
                fetchFileContent(lastFailedFile);
            } else if (currentActiveFile) {
                fetchFileContent(currentActiveFile);
            }
        }

        // Refresh File Viewer
        function refreshFileViewer() {
            if (currentActiveFile) {
                fetchFileContent(currentActiveFile);
            }
        }

        // Include external API if available
        function loadExternalAPI() {
            const script = document.createElement('script');
            script.src = 'dashboard/app.js';
            script.onerror = () => {
                console.log('External API not available, using fallback methods');
            };
            document.head.appendChild(script);
        }

        // Initialize dashboard on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadExternalAPI();
            initDashboard();
        });
    </script>
</body>
</html>